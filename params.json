{"name":"BioDSL","tagline":"Bioinformatics Domain Specific Language","body":"BioDSL (pronounced Biodiesel) is a Domain Specific Language for creating bioinformatic analysis workflows. A workflow may consist of several pipelines and each pipeline consists of a series of steps such as reading in data from a file, processing the data in some way, and writing data to a new file.\r\n\r\nBioDSL is build on the same principles as [Biopieces](www.biopieces.org), where data records are passed through multiple commands each with a specific task. The idea is that a command will process the data record if this contains the relevant attributes that the command can process. E.g. if a data record contains a sequence, then the command [reverse_seq](reverse_seq) will reverse that sequence.\r\n\r\n# Installation\r\n\r\nThe recommended way of installing BioDSL is via Ruby’s gem package manager:\r\n\r\n`$ gem install BioDSL`\r\n\r\nFor those commands which are wrappers around third-party tools, such as Usearch, Mothur and SPAdes, you will have to install these and make the executables available in your `$PATH`.\r\n\r\n# Getting started\r\n\r\nBioDSL is implemented in Ruby making use of Ruby’s powerful metaprogramming facilities. Thus, a workflow is basically a Ruby script containing one or more pipelines.\r\n\r\nHere is a test script with a single pipeline that reads all FASTA entries from the file `input.fna`, selects all records with a sequence ending in `ATC`, and writing those records as FASTA entries to the file `output.fna`:\r\n\r\n```\r\n#!/usr/bin/env ruby\r\n    \r\nrequire 'BioDSL'\r\n    \r\nBD.new.\r\nread_fasta(input: \"input.fna\").\r\ngrab(select: \"ATC$\", keys: :SEQ).\r\nwrite_fasta(output: \"output.fna\").\r\nrun\r\n```\r\n\r\nSave the test script to a file `test.biodsl` and execute on the command line:\r\n\r\n```\r\n$ ruby test.biodsl\r\n```\r\n\r\n# Combining multiple pipelines\r\n\r\nThis script demonstrates how multiple pipelines can be created and combined. In the end two pipelines are run, one consisting of p1 + p2 and one consisting of p1 + p3. The first pipeline run will produce a histogram plot of sequence length from sequences containing the pattern `ATCG`, and the other pipeline run will produce a plot with sequences length distribution of sequences not matching `ATCG`.\r\n\r\n```\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'BioDSL'\r\n\r\np1 = BD.new.read_fasta(input: \"test.fna\")\r\np2 = BD.new.grab(keys: :SEQ, select: \"ATCG\").\r\n     plot_histogram(key: :SEQ_LEN, terminal: :png, output: \"select.png\")\r\np3 = BD.new.grab(keys: :SEQ, reject: \"ATCG\").\r\n     plot_histogram(key: :SEQ_LEN, terminal: :png, output: \"reject.png\")\r\np4 = p1 + p3\r\n\r\n(p1 + p2).write_fasta(output: \"select.fna\").run\r\np4.write_fasta(output: \"reject.fna\").run\r\n```\r\n\r\n# Running pipelines in parallel\r\n\r\nThis script demonstrates how to run multiple pipelines in parallel using 20 CPU cores. Here we filter pair-end FASTQ entries from a list of samples described in the file `samples.txt` which contains three tab separated columns: sample name, a forward read file path, and a reverse read file path.\r\n\r\n```\r\n#!/usr/bin/env ruby\r\n\r\nrequire 'BioDSL'\r\nrequire 'csv'\r\n\r\nsamples = CSV.read(\"samples.txt\")\r\n\r\nParallel.each(samples, in_processes: 20) do |sample|\r\n  BD.new.\r\n  read_fastq(input: sample[1], input2: sample[2], encoding: :base_33).\r\n  grab(keys: :SEQ, select: \"ATCG\").\r\n  write_fastq(output: \"#{sample[0]}_filted.fastq.bz2\", bzip2: true).\r\n  run\r\nend\r\n```\r\n\r\n# Ruby one-liners\r\n\r\nIt is possible to execute BioDSL pipelines on the command line:\r\n\r\n```\r\nruby -r BioDSL -e 'BD.new.read_fasta(input: \"test.fna\").plot_histogram(key: :SEQ_LEN).run'\r\n```\r\n\r\nAnd to save typing we may use the alias `bd` which is set like this on the command line:\r\n\r\n```\r\n$ alias bd='ruby -r BioDSL'\r\n```\r\n\r\nIt may be a good idea to save that alias in your `.bashrc` file.\r\n\r\nNow it is possible to run a BioDSL pipeline on the command line like this:\r\n\r\n```\r\n$ bd -e 'BD.new.read_fasta(input: \"test.fna\").plot_histogram(key: :SEQ_LEN).run'\r\n```\r\n\r\n# Using the Interactive Ruby interpreter\r\n\r\nHere we demonstrate the use of Ruby's `irb` shell:\r\n\r\n```\r\n$ irb -r BioDSL --noinspect\r\nirb(main):001:0> p = BD.new\r\n=> BD.new\r\nirb(main):002:0> p.read_fasta(input: \"input.fna\")\r\n=> BD.new.read_fasta(input: \"input.fna\")\r\nirb(main):003:0> p.grab(select: \"ATC$\", keys: :SEQ)\r\n=> BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ)\r\nirb(main):004:0> p.write_fasta(output: \"output.fna\")\r\n=> BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\")\r\nirb(main):005:0> p.run\r\n=> BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run\r\nirb(main):006:0>\r\n```\r\n\r\nAgain, it may be a good idea to save an alias `alias biodsl=\"irb -r BioDSL --noinspect\"` to your `.bashrc` file. Thus, we can use the new `biodsl` alias to chain commands directly:\r\n\r\n    $ biodsl\r\n    irb(main):001:0> BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)\r\n    => BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)\r\n    irb(main):002:0>\r\n\r\n# History file\r\n\r\nA history file is kept in `$USER/.BioDSL_history` and each time run is called a history entry is added to this file:\r\n\r\n```\r\nBD.new.read_fasta(input: \"test_big.fna\", first: 100).plot_histogram(key: :SEQ_LEN).run\r\nBD.new.read_fasta(input: \"test_big.fna\", first: 100).plot_histogram(key: :SEQ_LEN).run\r\nBD.new.read_fasta(input: \"test_big.fna\", first: 10).plot_histogram(key: :SEQ_LEN).run\r\nBD.new.read_fasta(input: \"test_big.fna\").plot_histogram(key: :SEQ_LEN).run\r\nBD.new.read_fasta(input: \"test_big.fna\", first: 1000).plot_histogram(key: :SEQ_LEN).run\r\n```\r\n\r\nThus it is possible to redo the last pipeline by pasting the line in irb or a Ruby one-liner.\r\n\r\n# Log and History\r\n\r\nAll BioDSL events are logged to `~/.BioDSL_log`.\r\n\r\nBioDSL history is saved to `~/.BioDSL_history`.\r\n\r\n# Features\r\n\r\n## Progress\r\n\r\nShow nifty progress table with commands, records read and emittet and time.\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(progress: true)`\r\n\r\n## Verbose\r\n\r\nOutput verbose messages from commands and the run status.\r\n\r\n```\r\nBD.new.read_fasta(input: \"input.fna\").dump.run(verbose: true)\r\n```\r\n\r\n## Debug\r\n\r\nOutput debug messages from commands using these.\r\n\r\n```\r\nBD.new.read_fasta(input: \"input.fna\").dump.run(debug: true)\r\n```\r\n\r\n## E-mail notification\r\n\r\nSend an email when run is complete.\r\n\r\n```\r\nBD.new.read_fasta(input: \"input.fna\").dump.run(email: bill@hotmail.com, subject: \"Script done!\")\r\n```\r\n\r\n## Reports\r\n\r\nCreate an HTML report of the run stats for a pipeline:\r\n\r\n```\r\nBD.new.read_fasta(input: \"input.fna\").dump.run(report: \"status.html\")\r\n```\r\n\r\n## Output directory\r\n\r\nAll output files from commands are put in a specified directory:\r\n\r\n```\r\nBD.new.read_fasta(input: \"input.fna\").dump.run(output_dir: \"Results\")\r\n```\r\n\r\n## Configuration File\r\n\r\nIt is possible to pre-set options in a configuration file located in your `$HOME`\r\ndirectory called `.BioDSLrc`. Thus if an option is not already set, its value\r\nwill fall back to the one set in the configuration file. The configuration file\r\ncontains three whitespace separated columns:\r\n\r\n  * Command name\r\n  * Option\r\n  * Option value\r\n\r\nLines starting with `#` are considered comments and are ignored.\r\n\r\nAn example:\r\n\r\n```\r\nmaasha@mel:~$ cat ~/.BioDSLrc\r\nuchime_ref   database   /home/maasha/Install/QIIME1.8/data/rdp_gold.fa\r\nuchime_ref   cpus       20\r\n```\r\n\r\nOn compute clusters it is necessary to specify the max processor count, which\r\nis otherwise determined as the number of cores on the current node. To override\r\nthis add the following line:\r\n\r\n```\r\npipeline   processor_count   1000\r\n```\r\n\r\nIt is also possible to change the temporary directory from the systems default\r\nby adding the following line:\r\n\r\n```\r\npipeline   tmp_dir   /home/projects/ku_microbio/scratch/tmp\r\n```\r\n\r\n# Available BioDSL commands\r\n\r\n  * [add_key]                          (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AddKey)\r\n  * [align_seq_mothur]                 (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AlignSeqMothur)\r\n  * [analyze_residue_distribution]     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AnalyzeResidueDistribution)\r\n  * [assemble_pairs]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssemblePairs)\r\n  * [assemble_seq_idba]                (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqIdba)\r\n  * [assemble_seq_ray]                 (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqRay)\r\n  * [assemble_seq_spades]              (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqSpades)\r\n  * [classify_seq]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeq)\r\n  * [classify_seq_mothur]              (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeqMothur)\r\n  * [clip_primer]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClipPrimer)\r\n  * [cluster_otus]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClusterOtus)\r\n  * [collapse_otus]                    (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollapseOtus)\r\n  * [collect_otus]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollectOtus)\r\n  * [complement_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ComplementSeq)\r\n  * [count]                            (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Count)\r\n  * [degap_seq]                        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DegapSeq)\r\n  * [dereplicate_seq]                  (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DereplicateSeq)\r\n  * [dump]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Dump)\r\n  * [filter_rrna]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/FilterRrna)\r\n  * [genecall]                         (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Genecall)\r\n  * [grab]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Grab)\r\n  * [index_taxonomy]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/IndexTaxonomy)\r\n  * [mean_scores]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MeanScores)\r\n  * [merge_pair_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergePairSeq)\r\n  * [merge_table]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeTable)\r\n  * [merge_values]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeValues)\r\n  * [plot_heatmap]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHeatmap)\r\n  * [plot_histogram]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHistogram)\r\n  * [plot_matches]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotMatches)\r\n  * [plot_residue_distribution]        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotResidueDistribution)\r\n  * [plot_scores]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotScores)\r\n  * [random]                           (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Random)\r\n  * [read_fasta]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFasta)\r\n  * [read_fastq]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFastq)\r\n  * [read_table]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadTable)\r\n  * [reverse_seq]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReverseSeq)\r\n  * [slice_align]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceAlign)\r\n  * [slice_seq]                        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceSeq)\r\n  * [sort]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Sort)\r\n  * [split_pair_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitPairSeq)\r\n  * [split_values]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitValues)\r\n  * [trim_primer]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimPrimer)\r\n  * [trim_seq]                         (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimSeq)\r\n  * [uchime_ref]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UchimeRef)\r\n  * [unique_values]                    (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UniqueValues)\r\n  * [usearch_global]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UsearchGlobal)\r\n  * [write_fasta]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFasta)\r\n  * [write_fastq]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFastq)\r\n  * [write_table]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTable)\r\n  * [write_tree]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTree)\r\n\r\n\r\n# Contributing\r\n\r\n1. Fork it\r\n1. Create your feature branch (git checkout -b my-new-feature)\r\n1. Commit your changes (git commit -am 'Add some feature')\r\n1. Push to the branch (git push origin my-new-feature)\r\n1. Create new Pull Request","google":"UA-70265737-1","note":"Don't delete this file! It's used internally to help with page regeneration."}