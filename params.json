{"name":"BioDSL","tagline":"Bioinformatics Domain Specific Language","body":"BioDSL (pronounced Biodiesel) is a Domain Specific Language for creating bioinformatic analysis workflows. A workflow may consist of several pipelines and each pipeline consists of a series of steps such as reading in data from a file, processing the data in some way, and writing data to a new file.\r\n\r\nBioDSL is build on the same principles as [Biopieces](www.biopieces.org), where data records are passed through multiple commands each with a specific task. The idea is that a command will process the data record if this contains the relevant attributes that the command can process. E.g. if a data record contains a sequence, then the command [reverse_seq](reverse_seq) will reverse that sequence.\r\n\r\nInstallation\r\n------------\r\n\r\n`gem install BioDSL`\r\n\r\nGetting started\r\n---------------\r\n\r\nA test script:\r\n\r\n    #!/usr/bin/env ruby\r\n    \r\n    require 'BioDSL'\r\n    \r\n    p = BD.new.\r\n    read_fasta(input: \"input.fna\").\r\n    grab(select: \"ATC$\", keys: :SEQ).\r\n    write_fasta(output: \"output.fna\").\r\n    run(progress: true)\r\n\r\nOr using an interactive shell using the alias ibp which you can create by\r\nadding the following to your `~/.bashrc` file:\r\n\r\n    alias ibp=\"irb -r BioDSL --noinspect\"\r\n\r\nAnd then start the interactive shell:\r\n\r\n    $ ibp\r\n    irb(main):001:0> p = BD.new\r\n    => BD.new\r\n    irb(main):002:0> p.read_fasta(input: \"input.fna\")\r\n    => BD.new.read_fasta(input: \"input.fna\")\r\n    irb(main):003:0> p.grab(select: \"ATC$\", keys: :SEQ)\r\n    => BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ)\r\n    irb(main):004:0> p.write_fasta(output: \"output.fna\")\r\n    => BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\")\r\n    irb(main):005:0> p.run(progress: true)\r\n    => BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)\r\n    irb(main):006:0>\r\n\r\n\r\nOr chaining commands directly:\r\n\r\n    $ ibp\r\n    irb(main):001:0> BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)\r\n    => BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)\r\n    irb(main):002:0>\r\n\r\nOr run on the command line with the alias bp which you can create by adding the\r\nfollowing to your ~/.bashrc file:\r\n\r\n    alias bp=\"ruby -r BioDSL\"\r\n\r\nThen you can run the below from the command line:\r\n\r\n    $ bp -e 'BD.new.read_fasta(input: \"input.fna\").grab(select: \"ATC$\", keys: :SEQ).write_fasta(output: \"output.fna\").run(progress: true)'\r\n\r\nAvailable BioDSL\r\n-------------------\r\n\r\n  * [add_key]                          (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AddKey)                          \r\n  * [align_seq_mothur]                 (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AlignSeqMothur)                          \r\n  * [analyze_residue_distribution]     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AnalyzeResidueDistribution)\r\n  * [assemble_pairs]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssemblePairs)\r\n  * [assemble_seq_idba]                (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqIdba)\r\n  * [assemble_seq_ray]                 (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqRay)\r\n  * [assemble_seq_spades]              (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqSpades)\r\n  * [classify_seq]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeq)\r\n  * [classify_seq_mothur]              (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeqMothur)\r\n  * [clip_primer]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClipPrimer)\r\n  * [cluster_otus]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClusterOtus)\r\n  * [collapse_otus]                    (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollapseOtus)\r\n  * [collect_otus]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollectOtus)\r\n  * [complement_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ComplementSeq)\r\n  * [count]                            (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Count)\r\n  * [degap_seq]                        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DegapSeq)\r\n  * [dereplicate_seq]                  (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DereplicateSeq)\r\n  * [dump]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Dump)\r\n  * [filter_rrna]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/FilterRrna)\r\n  * [genecall]                         (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Genecall)\r\n  * [grab]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Grab)\r\n  * [index_taxonomy]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/IndexTaxonomy)\r\n  * [mean_scores]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MeanScores)\r\n  * [merge_pair_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergePairSeq)\r\n  * [merge_table]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeTable)\r\n  * [merge_values]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeValues)\r\n  * [plot_heatmap]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHeatmap)\r\n  * [plot_histogram]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHistogram)\r\n  * [plot_matches]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotMatches)\r\n  * [plot_residue_distribution]        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotResidueDistribution)\r\n  * [plot_scores]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotScores)\r\n  * [random]                           (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Random)\r\n  * [read_fasta]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFasta)\r\n  * [read_fastq]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFastq)\r\n  * [read_table]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadTable)\r\n  * [reverse_seq]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReverseSeq)\r\n  * [slice_align]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceAlign)\r\n  * [slice_seq]                        (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceSeq)\r\n  * [sort]                             (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Sort)\r\n  * [split_pair_seq]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitPairSeq)\r\n  * [split_values]                     (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitValues)\r\n  * [trim_primer]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimPrimer)\r\n  * [trim_seq]                         (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimSeq)\r\n  * [uchime_ref]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UchimeRef)\r\n  * [unique_values]                    (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UniqueValues)\r\n  * [usearch_global]                   (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UsearchGlobal)\r\n  * [write_fasta]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFasta)\r\n  * [write_fastq]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFastq)\r\n  * [write_table]                      (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTable)\r\n  * [write_tree]                       (http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTree)\r\n\r\nLog and History\r\n---------------\r\n\r\nAll BioDSL events are logged to `~/.BioDSL_log`.\r\n\r\nBioDSL history is saved to `~/.BioDSL_history`.\r\n\r\n\r\nFeatures\r\n--------\r\n\r\nProgress:\r\n\r\nShow nifty progress table with commands, records read and emittet and time.\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(progress: true)`\r\n\r\nVerbose:\r\n\r\nOutput verbose messages from commands and the run status.\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(verbose: true)`\r\n\r\nDebug:\r\n\r\nOutput debug messages from commands using these.\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(debug: true)`\r\n\r\nE-mail notification:\r\n\r\nSend an email when run is complete.\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(email: mail@maasha.dk, subject: \"Script done!\")`\r\n\r\nReport:\r\n\r\nCreate an HTML report of the run stats:\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(report: \"status.html\")`\r\n\r\nOutput dir:\r\n\r\nAll output files from commands are put in a specified dir:\r\n\r\n`BD.new.read_fasta(input: \"input.fna\").dump.run(output_dir: \"Results\")`\r\n\r\n\r\nConfiguration File\r\n------------------\r\n\r\nIt is possible to pre-set options in a configuration file located in your $HOME\r\ndirectory called `.BioDSLrc`. Thus if an option is not already set, its value\r\nwill fall back to the one set in the configuration file. The configuration file\r\ncontains three whitespace separated columns:\r\n\r\n  * Command name\r\n  * Option\r\n  * Option value\r\n\r\nLines starting with '#' are considered comments and are ignored.\r\n\r\nAn example:\r\n\r\n    maasha@mel:~$ cat ~/.BioDSLrc\r\n    uchime_ref   database   /home/maasha/Install/QIIME1.8/data/rdp_gold.fa\r\n    uchime_ref   cpus       20\r\n\r\nOn compute clusters it is necessary to specify the max processor count, which\r\nis otherwise determined as the number of cores on the current node. To override\r\nthis add the following line:\r\n\r\n    pipeline   processor_count   1000\r\n\r\nIt is also possible to change the temporary directory from the systems default\r\nby adding the following line:\r\n\r\n    pipeline   tmp_dir   /home/projects/ku_microbio/scratch/tmp\r\n\r\nContributing\r\n------------\r\n\r\nFork it\r\n\r\nCreate your feature branch (git checkout -b my-new-feature)\r\n\r\nCommit your changes (git commit -am 'Add some feature')\r\n\r\nPush to the branch (git push origin my-new-feature)\r\n\r\nCreate new Pull Request","google":"UA-70265737-1","note":"Don't delete this file! It's used internally to help with page regeneration."}