<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>BioDSL by maasha</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">BioDSL</h1>
      <h2 class="project-tagline">Bioinformatics Domain Specific Language</h2>
      <a href="https://github.com/maasha/BioDSL" class="btn">View on GitHub</a>
      <a href="https://github.com/maasha/BioDSL/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/maasha/BioDSL/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>BioDSL (pronounced Biodiesel) is a Domain Specific Language for creating bioinformatic analysis workflows. A workflow may consist of several pipelines and each pipeline consists of a series of steps such as reading in data from a file, processing the data in some way, and writing data to a new file.</p>

<p>BioDSL is build on the same principles as <a href="www.biopieces.org">Biopieces</a>, where data records are passed through multiple commands each with a specific task. The idea is that a command will process the data record if this contains the relevant attributes that the command can process. E.g. if a data record contains a sequence, then the command <a href="reverse_seq">reverse_seq</a> will reverse that sequence.</p>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h1>

<p>The recommended way of installing BioDSL is via Ruby’s gem package manager:</p>

<p><code>$ gem install BioDSL</code></p>

<p>For those commands which are wrappers around third-party tools, such as Usearch, Mothur and SPAdes, you will have to install these and make the executables available in your <code>$PATH</code>.</p>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<p>BioDSL is implemented in Ruby making use of Ruby’s powerful metaprogramming facilities. Thus, a workflow is basically a Ruby script containing one or more pipelines.</p>

<p>Here is a test script with a single pipeline that reads all FASTA entries from the file <code>input.fna</code>, selects all records with a sequence ending in <code>ATC</code>, and writing those records as FASTA entries to the file <code>output.fna</code>:</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'

BD.new.
read_fasta(input: "input.fna").
grab(select: "ATC$", keys: :SEQ).
write_fasta(output: "output.fna").
run
</code></pre>

<p>Save the test script to a file <code>test.biodsl</code> and execute on the command line:</p>

<pre><code>$ ruby test.biodsl
</code></pre>

<h1>
<a id="combining-multiple-pipelines" class="anchor" href="#combining-multiple-pipelines" aria-hidden="true"><span class="octicon octicon-link"></span></a>Combining multiple pipelines</h1>

<p>This script demonstrates how multiple pipelines can be created and combined. In the end two pipelines are run, one consisting of p1 + p2 and one consisting of p1 + p3. The first pipeline run will produce a histogram plot of sequence length from sequences containing the pattern <code>ATCG</code>, and the other pipeline run will produce a plot with sequences length distribution of sequences not matching <code>ATCG</code>.</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'

p1 = BD.new.read_fasta(input: "test.fna")
p2 = BD.new.grab(keys: :SEQ, select: "ATCG").
     plot_histogram(key: :SEQ_LEN, terminal: :png, output: "select.png")
p3 = BD.new.grab(keys: :SEQ, reject: "ATCG").
     plot_histogram(key: :SEQ_LEN, terminal: :png, output: "reject.png")
p4 = p1 + p3

(p1 + p2).write_fasta(output: "select.fna").run
p4.write_fasta(output: "reject.fna").run
</code></pre>

<h1>
<a id="running-pipelines-in-parallel" class="anchor" href="#running-pipelines-in-parallel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running pipelines in parallel</h1>

<p>This script demonstrates how to run multiple pipelines in parallel using 20 CPU cores. Here we filter pair-end FASTQ entries from a list of samples described in the file <code>samples.txt</code> which contains three tab separated columns: sample name, a forward read file path, and a reverse read file path.</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'
require 'csv'

samples = CSV.read("samples.txt")

Parallel.each(samples, in_processes: 20) do |sample|
  BD.new.
  read_fastq(input: sample[1], input2: sample[2], encoding: :base_33).
  grab(keys: :SEQ, select: "ATCG").
  write_fastq(output: "#{sample[0]}_filted.fastq.bz2", bzip2: true).
  run
end
</code></pre>

<h1>
<a id="ruby-one-liners" class="anchor" href="#ruby-one-liners" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby one-liners</h1>

<p>It is possible to execute BioDSL pipelines on the command line:</p>

<pre><code>ruby -r BioDSL -e 'BD.new.read_fasta(input: "test.fna").plot_histogram(key: :SEQ_LEN).run'
</code></pre>

<p>And to save typing we may use the alias <code>bd</code> which is set like this on the command line:</p>

<pre><code>$ alias bd='ruby -r BioDSL'
</code></pre>

<p>It may be a good idea to save that alias in your <code>.bashrc</code> file.</p>

<p>Now it is possible to run a BioDSL pipeline on the command line like this:</p>

<pre><code>$ bd -e 'BD.new.read_fasta(input: "test.fna").plot_histogram(key: :SEQ_LEN).run'
</code></pre>

<h1>
<a id="using-the-interactive-ruby-interpreter" class="anchor" href="#using-the-interactive-ruby-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using the Interactive Ruby interpreter</h1>

<p>Here we demonstrate the use of Ruby's <code>irb</code> shell:</p>

<pre><code>$ irb -r BioDSL --noinspect
irb(main):001:0&gt; p = BD.new
=&gt; BD.new
irb(main):002:0&gt; p.read_fasta(input: "input.fna")
=&gt; BD.new.read_fasta(input: "input.fna")
irb(main):003:0&gt; p.grab(select: "ATC$", keys: :SEQ)
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ)
irb(main):004:0&gt; p.write_fasta(output: "output.fna")
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna")
irb(main):005:0&gt; p.run
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run
irb(main):006:0&gt;
</code></pre>

<p>Again, it may be a good idea to save an alias <code>alias biodsl="irb -r BioDSL --noinspect"</code> to your <code>.bashrc</code> file. Thus, we can use the new <code>biodsl</code> alias to chain commands directly:</p>

<pre><code>$ biodsl
irb(main):001:0&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)
irb(main):002:0&gt;
</code></pre>

<h1>
<a id="history-file" class="anchor" href="#history-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>History file</h1>

<p>A history file is kept in <code>$USER/.BioDSL_history</code> and each time run is called a history entry is added to this file:</p>

<pre><code>BD.new.read_fasta(input: "test_big.fna", first: 100).plot_histogram(key: :SEQ_LEN).run
BD.new.read_fasta(input: "test_big.fna", first: 100).plot_histogram(key: :SEQ_LEN).run
BD.new.read_fasta(input: "test_big.fna", first: 10).plot_histogram(key: :SEQ_LEN).run
BD.new.read_fasta(input: "test_big.fna").plot_histogram(key: :SEQ_LEN).run
BD.new.read_fasta(input: "test_big.fna", first: 1000).plot_histogram(key: :SEQ_LEN).run
</code></pre>

<p>Thus it is possible to redo the last pipeline by pasting the line in irb or a Ruby one-liner.</p>

<h1>
<a id="log-and-history" class="anchor" href="#log-and-history" aria-hidden="true"><span class="octicon octicon-link"></span></a>Log and History</h1>

<p>All BioDSL events are logged to <code>~/.BioDSL_log</code>.</p>

<p>BioDSL history is saved to <code>~/.BioDSL_history</code>.</p>

<h1>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h1>

<h2>
<a id="progress" class="anchor" href="#progress" aria-hidden="true"><span class="octicon octicon-link"></span></a>Progress</h2>

<p>Show nifty progress table with commands, records read and emittet and time.</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(progress: true)</code></p>

<h2>
<a id="verbose" class="anchor" href="#verbose" aria-hidden="true"><span class="octicon octicon-link"></span></a>Verbose</h2>

<p>Output verbose messages from commands and the run status.</p>

<pre><code>BD.new.read_fasta(input: "input.fna").dump.run(verbose: true)
</code></pre>

<h2>
<a id="debug" class="anchor" href="#debug" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debug</h2>

<p>Output debug messages from commands using these.</p>

<pre><code>BD.new.read_fasta(input: "input.fna").dump.run(debug: true)
</code></pre>

<h2>
<a id="e-mail-notification" class="anchor" href="#e-mail-notification" aria-hidden="true"><span class="octicon octicon-link"></span></a>E-mail notification</h2>

<p>Send an email when run is complete.</p>

<pre><code>BD.new.read_fasta(input: "input.fna").dump.run(email: bill@hotmail.com, subject: "Script done!")
</code></pre>

<h2>
<a id="reports" class="anchor" href="#reports" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reports</h2>

<p>Create an HTML report of the run stats for a pipeline:</p>

<pre><code>BD.new.read_fasta(input: "input.fna").dump.run(report: "status.html")
</code></pre>

<h2>
<a id="output-directory" class="anchor" href="#output-directory" aria-hidden="true"><span class="octicon octicon-link"></span></a>Output directory</h2>

<p>All output files from commands are put in a specified directory:</p>

<pre><code>BD.new.read_fasta(input: "input.fna").dump.run(output_dir: "Results")
</code></pre>

<h2>
<a id="configuration-file" class="anchor" href="#configuration-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration File</h2>

<p>It is possible to pre-set options in a configuration file located in your <code>$HOME</code>
directory called <code>.BioDSLrc</code>. Thus if an option is not already set, its value
will fall back to the one set in the configuration file. The configuration file
contains three whitespace separated columns:</p>

<ul>
<li>Command name</li>
<li>Option</li>
<li>Option value</li>
</ul>

<p>Lines starting with <code>#</code> are considered comments and are ignored.</p>

<p>An example:</p>

<pre><code>maasha@mel:~$ cat ~/.BioDSLrc
uchime_ref   database   /home/maasha/Install/QIIME1.8/data/rdp_gold.fa
uchime_ref   cpus       20
</code></pre>

<p>On compute clusters it is necessary to specify the max processor count, which
is otherwise determined as the number of cores on the current node. To override
this add the following line:</p>

<pre><code>pipeline   processor_count   1000
</code></pre>

<p>It is also possible to change the temporary directory from the systems default
by adding the following line:</p>

<pre><code>pipeline   tmp_dir   /home/projects/ku_microbio/scratch/tmp
</code></pre>

<h1>
<a id="available-biodsl-commands" class="anchor" href="#available-biodsl-commands" aria-hidden="true"><span class="octicon octicon-link"></span></a>Available BioDSL commands</h1>

<ul>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AddKey">add_key</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AlignSeqMothur">align_seq_mothur</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AnalyzeResidueDistribution">analyze_residue_distribution</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssemblePairs">assemble_pairs</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqIdba">assemble_seq_idba</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqRay">assemble_seq_ray</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqSpades">assemble_seq_spades</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeq">classify_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeqMothur">classify_seq_mothur</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClipPrimer">clip_primer</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClusterOtus">cluster_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollapseOtus">collapse_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollectOtus">collect_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ComplementSeq">complement_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Count">count</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DegapSeq">degap_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DereplicateSeq">dereplicate_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Dump">dump</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/FilterRrna">filter_rrna</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Genecall">genecall</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Grab">grab</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/IndexTaxonomy">index_taxonomy</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MeanScores">mean_scores</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergePairSeq">merge_pair_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeTable">merge_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeValues">merge_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHeatmap">plot_heatmap</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHistogram">plot_histogram</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotMatches">plot_matches</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotResidueDistribution">plot_residue_distribution</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotScores">plot_scores</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Random">random</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFasta">read_fasta</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFastq">read_fastq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadTable">read_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReverseSeq">reverse_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceAlign">slice_align</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceSeq">slice_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Sort">sort</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitPairSeq">split_pair_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitValues">split_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimPrimer">trim_primer</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimSeq">trim_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UchimeRef">uchime_ref</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UniqueValues">unique_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UsearchGlobal">usearch_global</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFasta">write_fasta</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFastq">write_fastq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTable">write_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTree">write_tree</a></li>
</ul>

<h1>
<a id="running-the-test-suite" class="anchor" href="#running-the-test-suite" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running the test suite</h1>

<p>BioDSL have an extended set of unit tests that can be run after installing development dependencies. First you need to install the bundler gem:</p>

<pre><code>$ gem install bundler
</code></pre>

<p>Next you need to change to the source directory of BioDSL and run bundler to download depending gems:</p>

<pre><code>$ bundle install
</code></pre>

<p>And then you run the test suite by running <code>rake</code>:</p>

<pre><code>$ rake
</code></pre>

<p>And the unit tests should all run, except those omitted because a third-party executable was missing.</p>

<h1>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h1>

<ol>
<li>Fork it</li>
<li>Create your feature branch (git checkout -b my-new-feature)</li>
<li>Commit your changes (git commit -am 'Add some feature')</li>
<li>Push to the branch (git push origin my-new-feature)</li>
<li>Create new Pull Request</li>
</ol>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/maasha/BioDSL">BioDSL</a> is maintained by <a href="https://github.com/maasha">maasha</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-70265737-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
