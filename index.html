<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>BioDSL by maasha</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">BioDSL</h1>
      <h2 class="project-tagline">Bioinformatics Domain Specific Language</h2>
      <a href="https://github.com/maasha/BioDSL" class="btn">View on GitHub</a>
      <a href="https://github.com/maasha/BioDSL/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/maasha/BioDSL/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>BioDSL (pronounced Biodiesel) is a Domain Specific Language for creating bioinformatic analysis workflows. A workflow may consist of several pipelines and each pipeline consists of a series of steps such as reading in data from a file, processing the data in some way, and writing data to a new file.</p>

<p>BioDSL is build on the same principles as <a href="www.biopieces.org">Biopieces</a>, where data records are passed through multiple commands each with a specific task. The idea is that a command will process the data record if this contains the relevant attributes that the command can process. E.g. if a data record contains a sequence, then the command <a href="reverse_seq">reverse_seq</a> will reverse that sequence.</p>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h1>

<p>The recommended way of installing BioDSL is via Ruby’s gem package manager:</p>

<p><code>gem install BioDSL</code></p>

<p>For those commands which are wrappers around third-party tools, such as Usearch, Mothur and SPAdes, you will have to install these and make the executables available in your <code>$PATH</code>.</p>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<p>BioDSL is implemented in Ruby making use of Ruby’s powerful metaprogramming facilities. Thus, a workflow is basically a Ruby script containing one or more pipelines.</p>

<p>Here is a test script that with a single pipeline that reads all FASTA entries from the file <code>input.fna</code>, selects all records with a sequence ending in <code>ATC</code>, and writing those records as FASTA entries to the file <code>output.fna</code>:</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'

p = BD.new.
read_fasta(input: "input.fna").
grab(select: "ATC$", keys: :SEQ).
write_fasta(output: "output.fna").
run(progress: true)
</code></pre>

<p>Save the test script to a file <code>test.biodsl</code> and execute on the command line:</p>

<pre><code>$ ruby test.biodsl
</code></pre>

<h1>
<a id="combining-multiple-pipelines" class="anchor" href="#combining-multiple-pipelines" aria-hidden="true"><span class="octicon octicon-link"></span></a>Combining multiple pipelines</h1>

<p>This script demonstrates how multiple pipelines can be created and combined. In the end two pipelines are run, one consisting of p1 + p2 and one consisting of p1 + p3.</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'

p1 = BD.new.read_fasta(input: "test.fna")
p2 = BD.new.grab(keys: :SEQ, select: "ATCG").
     plot_histogram(key: :SEQ_LEN, terminal: :png, output: "select.png")
p3 = BD.new.grab(keys: :SEQ, reject: "ATCG").
     plot_histogram(key: :SEQ_LEN, terminal: :png, output: "reject.png")
p4 = p1 + p3
(p1 + p2).write_fasta(output: "select.fna").run(progress: true)
p4.write_fasta(output: "reject.fna").run(progress: true)
</code></pre>

<h1>
<a id="running-pipelines-in-parallel" class="anchor" href="#running-pipelines-in-parallel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running pipelines in parallel</h1>

<p>This script demonstrates how to run multiple pipelines in parallel. Here we filter pair-end FASTQ entries from a list of samples, each consisting of a sample name, a forward read file and a reverse read file is processed in parallel.</p>

<pre><code>#!/usr/bin/env ruby

require 'BioDSL'

samples = read_samples("samples.txt)

Parallel.each(samples, in_processes: 20) do |sample|
  BD.new.
  read_fastq(input: sample[1], input2: sample[2], encoding: :base_33).
  grab(keys: :SEQ, select: "ATCG").
  write_fastq(output: "#{sample[0]}_filted.fastq.bz2", bzip2: true).
  run
end
</code></pre>

<h1>
<a id="ruby-one-liner" class="anchor" href="#ruby-one-liner" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby one-liner</h1>

<p>Here we use the alias bp which is set in .bashrc like this: alias bd='ruby -r BioDSL':</p>

<pre><code>$ bd -e 'BD.new.read_fasta(input: "test_big.fna", first: 1000).plot_histogram(key: :SEQ_LEN).run'
</code></pre>

<h1>
<a id="using-the-interactive-ruby-interpreter" class="anchor" href="#using-the-interactive-ruby-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using the Interactive Ruby interpreter</h1>

<p>Or using an interactive shell using the alias ibp which you can create by
adding the following to your <code>~/.bashrc</code> file:</p>

<pre><code>alias ibp="irb -r BioDSL --noinspect"
</code></pre>

<p>And then start the interactive shell:</p>

<pre><code>$ ibp
irb(main):001:0&gt; p = BD.new
=&gt; BD.new
irb(main):002:0&gt; p.read_fasta(input: "input.fna")
=&gt; BD.new.read_fasta(input: "input.fna")
irb(main):003:0&gt; p.grab(select: "ATC$", keys: :SEQ)
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ)
irb(main):004:0&gt; p.write_fasta(output: "output.fna")
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna")
irb(main):005:0&gt; p.run(progress: true)
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)
irb(main):006:0&gt;
</code></pre>

<p>Or chaining commands directly:</p>

<pre><code>$ ibp
irb(main):001:0&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)
=&gt; BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)
irb(main):002:0&gt;
</code></pre>

<p>Or run on the command line with the alias bp which you can create by adding the
following to your ~/.bashrc file:</p>

<pre><code>alias bp="ruby -r BioDSL"
</code></pre>

<p>Then you can run the below from the command line:</p>

<pre><code>$ bp -e 'BD.new.read_fasta(input: "input.fna").grab(select: "ATC$", keys: :SEQ).write_fasta(output: "output.fna").run(progress: true)'
</code></pre>

<h2>
<a id="available-biodsl" class="anchor" href="#available-biodsl" aria-hidden="true"><span class="octicon octicon-link"></span></a>Available BioDSL</h2>

<ul>
<li>
<a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AddKey">add_key</a><br>
</li>
<li>
<a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AlignSeqMothur">align_seq_mothur</a><br>
</li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AnalyzeResidueDistribution">analyze_residue_distribution</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssemblePairs">assemble_pairs</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqIdba">assemble_seq_idba</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqRay">assemble_seq_ray</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/AssembleSeqSpades">assemble_seq_spades</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeq">classify_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClassifySeqMothur">classify_seq_mothur</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClipPrimer">clip_primer</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ClusterOtus">cluster_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollapseOtus">collapse_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/CollectOtus">collect_otus</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ComplementSeq">complement_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Count">count</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DegapSeq">degap_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/DereplicateSeq">dereplicate_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Dump">dump</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/FilterRrna">filter_rrna</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Genecall">genecall</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Grab">grab</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/IndexTaxonomy">index_taxonomy</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MeanScores">mean_scores</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergePairSeq">merge_pair_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeTable">merge_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/MergeValues">merge_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHeatmap">plot_heatmap</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotHistogram">plot_histogram</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotMatches">plot_matches</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotResidueDistribution">plot_residue_distribution</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/PlotScores">plot_scores</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Random">random</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFasta">read_fasta</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadFastq">read_fastq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReadTable">read_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/ReverseSeq">reverse_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceAlign">slice_align</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SliceSeq">slice_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/Sort">sort</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitPairSeq">split_pair_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/SplitValues">split_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimPrimer">trim_primer</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/TrimSeq">trim_seq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UchimeRef">uchime_ref</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UniqueValues">unique_values</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/UsearchGlobal">usearch_global</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFasta">write_fasta</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteFastq">write_fastq</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTable">write_table</a></li>
<li><a href="http://www.rubydoc.info/gems/BioDSL/1.0.1/BioDSL/WriteTree">write_tree</a></li>
</ul>

<h2>
<a id="log-and-history" class="anchor" href="#log-and-history" aria-hidden="true"><span class="octicon octicon-link"></span></a>Log and History</h2>

<p>All BioDSL events are logged to <code>~/.BioDSL_log</code>.</p>

<p>BioDSL history is saved to <code>~/.BioDSL_history</code>.</p>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<p>Progress:</p>

<p>Show nifty progress table with commands, records read and emittet and time.</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(progress: true)</code></p>

<p>Verbose:</p>

<p>Output verbose messages from commands and the run status.</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(verbose: true)</code></p>

<p>Debug:</p>

<p>Output debug messages from commands using these.</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(debug: true)</code></p>

<p>E-mail notification:</p>

<p>Send an email when run is complete.</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(email: mail@maasha.dk, subject: "Script done!")</code></p>

<p>Report:</p>

<p>Create an HTML report of the run stats:</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(report: "status.html")</code></p>

<p>Output dir:</p>

<p>All output files from commands are put in a specified dir:</p>

<p><code>BD.new.read_fasta(input: "input.fna").dump.run(output_dir: "Results")</code></p>

<h2>
<a id="configuration-file" class="anchor" href="#configuration-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration File</h2>

<p>It is possible to pre-set options in a configuration file located in your $HOME
directory called <code>.BioDSLrc</code>. Thus if an option is not already set, its value
will fall back to the one set in the configuration file. The configuration file
contains three whitespace separated columns:</p>

<ul>
<li>Command name</li>
<li>Option</li>
<li>Option value</li>
</ul>

<p>Lines starting with '#' are considered comments and are ignored.</p>

<p>An example:</p>

<pre><code>maasha@mel:~$ cat ~/.BioDSLrc
uchime_ref   database   /home/maasha/Install/QIIME1.8/data/rdp_gold.fa
uchime_ref   cpus       20
</code></pre>

<p>On compute clusters it is necessary to specify the max processor count, which
is otherwise determined as the number of cores on the current node. To override
this add the following line:</p>

<pre><code>pipeline   processor_count   1000
</code></pre>

<p>It is also possible to change the temporary directory from the systems default
by adding the following line:</p>

<pre><code>pipeline   tmp_dir   /home/projects/ku_microbio/scratch/tmp
</code></pre>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>Fork it</p>

<p>Create your feature branch (git checkout -b my-new-feature)</p>

<p>Commit your changes (git commit -am 'Add some feature')</p>

<p>Push to the branch (git push origin my-new-feature)</p>

<p>Create new Pull Request</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/maasha/BioDSL">BioDSL</a> is maintained by <a href="https://github.com/maasha">maasha</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-70265737-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
